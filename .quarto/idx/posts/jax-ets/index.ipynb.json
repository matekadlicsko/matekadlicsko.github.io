{"title":"Implementing an ETS model in JAX","markdown":{"yaml":{"title":"Implementing an ETS model in JAX"},"headingText":"Imports and Setup","containsRefs":false,"markdown":"\n\n\n\n\nIn this notebook I demonstrate my [JAX](https://jax.readthedocs.io/en/latest/index.html) implementation of the [ETS variant commonly denoted as $(A_d, A)$](https://otexts.com/fpp2/taxonomy.html), which has an additive damped trend and an additive seasonality component.\nJAX is a high performance tensor library that offers functionalities like automatic differntiation, JIT compilation while having a familiar NumPy-like interface. However, there are some caveats, for example it only allows [pure functions](https://en.wikipedia.org/wiki/Pure_function) (so no side effects are allowed).\n\nThe main goal of this notebook is to explore JAX functionalities, especially [lax.scan](https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.scan.html), which offers a convenient way around writing for-loops.\n\nA much more detailed introduction to ETS models can be found in [Forecasting: Principles and Practice](https://otexts.com/fpp2/).\n\n\n\n\n## Data Loading\nWe will use the AirPassangers dataset.\n\n## [The scan function](https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.scan.html)\nLet's start with a quick run down on how the scan function works. A crude Python implementation of it would look like this:\n```python\ndef scan(f, init, xs, length=None):\n  if xs is None:\n    xs = [None] * length\n  carry = init\n  ys = []\n  for x in xs:\n    carry, y = f(carry, x)\n    ys.append(y)\n  return carry, np.stack(ys)\n```\nHere, `f` takes `carry`, which can be thought of as a state and an element `x` of `xs`, and returns a transformed `carry` and `y`. The scan function loops through the sequence `xs`, applying `f` to each element and updating the `carry` accordingly.\n\nAs an example we will calculate the square of cumulative sum of an integer sequence. Note that this implementation is not a very efficient one, we do it this way only for the sake of presentation.\n\n## Implementing the model\nWe are ready to start implementing the model, which is given by\n\n\\begin{aligned}\ny_t &= l_{t-1} + \\varphi b_{t-1} + s_{t - m} + \\varepsilon_{t}, \\\\\nl_t &= l_{t - 1} + \\varphi b_{t - 1} + \\alpha \\varepsilon_t, \\\\\nb_t &= b_{t-1} + \\beta \\varepsilon_t, \\\\\ns_{t} &= s_{t - m} + \\gamma \\varepsilon_t.\n\\end{aligned}\n\nThe conditional one step ahead expectation is given by\n\\begin{aligned}\n\\mu_{y, t} = l_{t-1} + \\varphi b_{t-1} + s_{t - m},\n\\end{aligned}\nand the conditional $h$ steps ahead expectation by\n\n\\begin{aligned}\n\\hat{y}_{t + h} = l_{t} + \\sum_{i=0}^h\\varphi^i b_{t-1} + s_{t - \\bigl\\lceil \\frac{h}{m} \\bigr\\rceil m + h}.\n\\end{aligned}\nThe later one might seem a bit obnoxious, but it can be derived from the model using $\\mathbb{E}(\\varepsilon) = 0$. Luckily, in our approach it suffices to always forecast one step ahead.\n\nTwo things to mention:\n\n\n1. When `obs` is `nan`, we want to return the conditional one step ahead expectation. To do this, we used the `jax.lax.cond` condition handler. This is equivalent to\n`0.0 if jnp.isnan(obs) else obs - forecast`, however [if-else statements are not allowed in `jit`-compiled functions](https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#python-control-flow-jit).\n2. Since JAX requires functions to be pure, [mutation of variables is not allowed](https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#in-place-updates), i.e.\n```python\nseason[0] = season[0] + gamma * epsilon\n```\nwould yield an error. Instead, we update the array using the syntax `.at[idx].set(y)`.\n\n\n\n\n## Prediction and optimization\n\nPredicting is now as easy as scanning using some `initial_state`. For optimization of parameters I used LBFGS from the [jaxopt](https://github.com/google/jaxopt) library with mean squared error as a loss function, however [other loss functions can also be considered](https://openforecast.org/adam/ADAMETSEstimationLikelihood.html).\n\nWe remark that constraints on the parameters could (and should) be imposed and the initial state should be optimized, instead of setting it heuristically, however we won't bother with that, since that is not the focus of this notebook. Again, I refer the reader to [Forecasting: Principles and Practice Chapter 8.6](https://otexts.com/fpp3/ets-estimation.html).\n\nNote that on the first run, `opt_coeffs` function is compiled, which slows things down.\n\nHowever, on later runs it should be pretty fast, especially on inputs of the same size, which sounds restrictive, but it can be solved using padding.\n","srcMarkdownNoYaml":"\n\n\n\n\nIn this notebook I demonstrate my [JAX](https://jax.readthedocs.io/en/latest/index.html) implementation of the [ETS variant commonly denoted as $(A_d, A)$](https://otexts.com/fpp2/taxonomy.html), which has an additive damped trend and an additive seasonality component.\nJAX is a high performance tensor library that offers functionalities like automatic differntiation, JIT compilation while having a familiar NumPy-like interface. However, there are some caveats, for example it only allows [pure functions](https://en.wikipedia.org/wiki/Pure_function) (so no side effects are allowed).\n\nThe main goal of this notebook is to explore JAX functionalities, especially [lax.scan](https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.scan.html), which offers a convenient way around writing for-loops.\n\nA much more detailed introduction to ETS models can be found in [Forecasting: Principles and Practice](https://otexts.com/fpp2/).\n\n\n\n## Imports and Setup\n\n## Data Loading\nWe will use the AirPassangers dataset.\n\n## [The scan function](https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.scan.html)\nLet's start with a quick run down on how the scan function works. A crude Python implementation of it would look like this:\n```python\ndef scan(f, init, xs, length=None):\n  if xs is None:\n    xs = [None] * length\n  carry = init\n  ys = []\n  for x in xs:\n    carry, y = f(carry, x)\n    ys.append(y)\n  return carry, np.stack(ys)\n```\nHere, `f` takes `carry`, which can be thought of as a state and an element `x` of `xs`, and returns a transformed `carry` and `y`. The scan function loops through the sequence `xs`, applying `f` to each element and updating the `carry` accordingly.\n\nAs an example we will calculate the square of cumulative sum of an integer sequence. Note that this implementation is not a very efficient one, we do it this way only for the sake of presentation.\n\n## Implementing the model\nWe are ready to start implementing the model, which is given by\n\n\\begin{aligned}\ny_t &= l_{t-1} + \\varphi b_{t-1} + s_{t - m} + \\varepsilon_{t}, \\\\\nl_t &= l_{t - 1} + \\varphi b_{t - 1} + \\alpha \\varepsilon_t, \\\\\nb_t &= b_{t-1} + \\beta \\varepsilon_t, \\\\\ns_{t} &= s_{t - m} + \\gamma \\varepsilon_t.\n\\end{aligned}\n\nThe conditional one step ahead expectation is given by\n\\begin{aligned}\n\\mu_{y, t} = l_{t-1} + \\varphi b_{t-1} + s_{t - m},\n\\end{aligned}\nand the conditional $h$ steps ahead expectation by\n\n\\begin{aligned}\n\\hat{y}_{t + h} = l_{t} + \\sum_{i=0}^h\\varphi^i b_{t-1} + s_{t - \\bigl\\lceil \\frac{h}{m} \\bigr\\rceil m + h}.\n\\end{aligned}\nThe later one might seem a bit obnoxious, but it can be derived from the model using $\\mathbb{E}(\\varepsilon) = 0$. Luckily, in our approach it suffices to always forecast one step ahead.\n\nTwo things to mention:\n\n\n1. When `obs` is `nan`, we want to return the conditional one step ahead expectation. To do this, we used the `jax.lax.cond` condition handler. This is equivalent to\n`0.0 if jnp.isnan(obs) else obs - forecast`, however [if-else statements are not allowed in `jit`-compiled functions](https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#python-control-flow-jit).\n2. Since JAX requires functions to be pure, [mutation of variables is not allowed](https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#in-place-updates), i.e.\n```python\nseason[0] = season[0] + gamma * epsilon\n```\nwould yield an error. Instead, we update the array using the syntax `.at[idx].set(y)`.\n\n\n\n\n## Prediction and optimization\n\nPredicting is now as easy as scanning using some `initial_state`. For optimization of parameters I used LBFGS from the [jaxopt](https://github.com/google/jaxopt) library with mean squared error as a loss function, however [other loss functions can also be considered](https://openforecast.org/adam/ADAMETSEstimationLikelihood.html).\n\nWe remark that constraints on the parameters could (and should) be imposed and the initial state should be optimized, instead of setting it heuristically, however we won't bother with that, since that is not the focus of this notebook. Again, I refer the reader to [Forecasting: Principles and Practice Chapter 8.6](https://otexts.com/fpp3/ets-estimation.html).\n\nNote that on the first run, `opt_coeffs` function is compiled, which slows things down.\n\nHowever, on later runs it should be pretty fast, especially on inputs of the same size, which sounds restrictive, but it can be solved using padding.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.554","theme":"cosmo","title-block-banner":true,"title":"Implementing an ETS model in JAX"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}